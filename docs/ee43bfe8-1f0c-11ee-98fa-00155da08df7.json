{"page_content": "[{\"level\": 1, \"title\": \" Pagination \", \"body\": [\" Pagination is the process of dividing data into discrete pages. In Appwrite, it is achieved by using an offset or a cursor, which both come with their own use case and benefits.\"]}, {\"level\": 2, \"title\": \"Offset Pagination\", \"body\": [\" Using Query.limit() and Query.offset() you can achieve one of the most common approaches to pagination. With Query.limit() you can define to how many documents that can be returned from one request. The Query.offset() is simply the number of records you wish to skip before selecting records.\", \"  Web  import { Client, Databases, Query } from \\\"appwrite\\\";\\n\\nconst client = new Client()\\n    .setEndpoint('https://cloud.appwrite.io/v1')\\n    .setProject('[PROJECT_ID]');\\n\\nconst databases = new Databases(client);\\n                \\n// Page 1\\nconst page1 = await databases.listDocuments(\\n    '[DATABASE_ID]',\\n    '[COLLECTION_ID]',\\n    [\\n        Query.limit(25),\\n        Query.offset(0)\\n    ]\\n);\\n\\n// Page 2\\nconst page2 = await databases.listDocuments(\\n    '[DATABASE_ID]',\\n    '[COLLECTION_ID]',\\n    [\\n        Query.limit(25),\\n        Query.offset(25)\\n    ]\\n);    Flutter  import 'package:appwrite/appwrite.dart';\\n\\nvoid main() async {\\n    final client = Client()\\n        .setEndpoint('https://cloud.appwrite.io/v1')\\n        .setProject('[PROJECT_ID]');\\n\\n    final databases = Databases(client);\\n\\n    final page1 = await databases.listDocuments(\\n        databaseId: '[DATABASE_ID]',\\n        collectionId: '[COLLECTION_ID]',\\n        queries: [\\n            Query.limit(25),\\n            Query.offset(0)\\n        ]\\n    );\\n\\n    final page2 = await databases.listDocuments(\\n        databaseId: '[DATABASE_ID]',\\n        collectionId: '[COLLECTION_ID]',\\n        queries: [\\n            Query.limit(25),\\n            Query.offset(25)\\n        ]\\n    );\\n}\\n    Android  import io.appwrite.Client\\nimport io.appwrite.Query\\nimport io.appwrite.services.Databases\\n\\nsuspend fun main() {\\n    val client = Client(applicationContext)\\n        .setEndpoint(\\\"https://cloud.appwrite.io/v1\\\")\\n        .setProject(\\\"[PROJECT_ID]\\\")\\n\\n    val databases = Databases(client)\\n\\n    val page1 = databases.listDocuments(\\n        databaseId = \\\"[DATABASE_ID]\\\",\\n        collectionId = \\\"[COLLECTION_ID]\\\",\\n        queries = [\\n            Query.limit(25),\\n            Query.offset(0)\\n        ]\\n    )\\n\\n    val page2 = databases.listDocuments(\\n        databaseId = \\\"[DATABASE_ID]\\\",\\n        collectionId = \\\"[COLLECTION_ID]\\\",\\n        queries = [\\n            Query.limit(25),\\n            Query.offset(25)\\n        ]\\n    )\\n}    Apple  import Appwrite\\nimport AppwriteModels\\n\\nfunc main() async throws {\\n    let client = Client()\\n        .setEndpoint(\\\"https://cloud.appwrite.io/v1\\\")\\n        .setProject(\\\"[PROJECT_ID]\\\")\\n\\n    let databases = Databases(client)\\n\\n    let page1 = try await databases.listDocuments(\\n        databaseId: \\\"[DATABASE_ID]\\\",\\n        collectionId: \\\"[COLLECTION_ID]\\\",\\n        queries: [\\n            Query.limit(25),\\n            Query.offset(0)\\n        ]\\n    )\\n\\n    let page2 = try await databases.listDocuments(\\n        databaseId: \\\"[DATABASE_ID]\\\",\\n        collectionId: \\\"[COLLECTION_ID]\\\",\\n        queries: [\\n            Query.limit(25),\\n            Query.offset(25)\\n        ]\\n    )\\n}  \", \" The request gets slower as the number of records increases because the database has to read up to the offset number of rows to know where it should start selecting data. Also when there is data added in high frequency - the individual pages might skip results.\"]}, {\"level\": 2, \"title\": \"Cursor Pagination\", \"body\": [\" The cursor is a unique identifier for a document that points to where the next page should start. After reading a page of documents, pass the last document's ID into the Query.cursorAfter(lastId) query method to get the next page of documents. Pass the first document's ID into the Query.cursorBefore(firstId) query method to retrieve the previous page.\", \"  Web  import { Databases, Query } from \\\"appwrite\\\";\\n\\nconst client = new Client()\\n    .setEndpoint(\\\"https://cloud.appwrite.io/v1\\\")\\n    .setProject(\\\"[PROJECT_ID]\\\");\\n\\nconst databases = new Databases(client);\\n\\n// Page 1\\nconst page1 = await databases.listDocuments(\\n    '[DATABASE_ID]',\\n    '[COLLECTION_ID]',\\n    [\\n        Query.limit(25),\\n    ]\\n);\\n\\nconst lastId = page1.documents[page1.documents.length - 1].$id;\\n\\n// Page 2\\nconst page2 = await databases.listDocuments(\\n    '[DATABASE_ID]',\\n    '[COLLECTION_ID]',\\n    [\\n        Query.limit(25),\\n        Query.cursorAfter(lastId),\\n    ]\\n);    Flutter  import 'package:appwrite/appwrite.dart';\\n\\nvoid main() async {\\n    final client = Client()\\n        .setEndpoint('https://cloud.appwrite.io/v1')\\n        .setProject('[PROJECT_ID]');\\n\\n    final databases = Databases(client);\\n\\n    final page1 = await databases.listDocuments(\\n        databaseId: '[DATABASE_ID]',\\n        collectionId: '[COLLECTION_ID]',\\n        queries: [\\n            Query.limit(25)\\n        ]\\n    );\\n\\n    final lastId = page1.documents[page1.documents.length - 1].$id;\\n\\n    final page2 = await databases.listDocuments(\\n        databaseId: '[DATABASE_ID]',\\n        collectionId: '[COLLECTION_ID]',\\n        queries: [\\n            Query.limit(25),\\n            Query.cursorAfter(lastId)\\n        ]\\n    );\\n\\n}\\n    Android  import android.util.Log\\nimport io.appwrite.AppwriteException\\nimport io.appwrite.Client\\nimport io.appwrite.Query\\nimport io.appwrite.services.Databases\\n\\nsuspend fun main() {\\n    val client = Client(applicationContext)\\n        .setEndpoint(\\\"https://cloud.appwrite.io/v1\\\")\\n        .setProject(\\\"[PROJECT_ID]\\\")\\n\\n    val databases = Databases(client)\\n\\n    val page1 = databases.listDocuments(\\n        databaseId = \\\"[DATABASE_ID]\\\",\\n        collectionId = \\\"[COLLECTION_ID]\\\",\\n        queries = [\\n            Query.limit(25)\\n        ]\\n    )\\n\\n    val lastId = page1.documents[page1.documents.size - 1].$id\\n\\n    val page2 = databases.listDocuments(\\n        databaseId = \\\"[DATABASE_ID]\\\",\\n        collectionId = \\\"[COLLECTION_ID]\\\",\\n        queries = [\\n            Query.limit(25),\\n            Query.cursorAfter(lastId)\\n        ]\\n    )\\n}    Apple  import Appwrite\\nimport AppwriteModels\\n\\nfunc main() async throws {\\n    let client = Client()\\n      .setEndpoint(\\\"https://cloud.appwrite.io/v1\\\")\\n      .setProject(\\\"[PROJECT_ID]\\\")\\n\\n    let databases = Databases(client)\\n\\n    let page1 = try await databases.listDocuments(\\n        databaseId: \\\"[DATABASE_ID]\\\",\\n        collectionId: \\\"[COLLECTION_ID]\\\",\\n        queries: [\\n            Query.limit(25)\\n        ]\\n    )\\n\\n    let lastId = page1.documents[page1.documents.count - 1].$id\\n\\n    let page2 = try await databases.listDocuments(\\n        databaseId: \\\"[DATABASE_ID]\\\",\\n        collectionId: \\\"[COLLECTION_ID]\\\",\\n        queries: [\\n            Query.limit(25),\\n            Query.cursorAfter(lastId)\\n        ]\\n    )\\n}  \"]}]", "metadata": {"source": "https://appwrite.io/docs/databases-pagination"}}