{"page_content": "[{\"level\": 1, \"title\": \" Examples \", \"body\": [\" Appwrite Functions is all about flexibility. Behind the simple workflow hides some useful examples that can help you accomplish your goals faster. Take a look at the following.\"]}, {\"level\": 2, \"title\": \"Currency Conversion API\", \"body\": [\" Here's a currency conversion API that converts from Euros and Indian Rupees to US Dollars. We'll use an external API to get the latest exchange rates, and query it using an dependency specific to each runtime.\"]}, {\"level\": 3, \"title\": \"Prerequisites\", \"body\": [\"  Node.js  Run the following bash command to create a package.json file. This file is used to manage your Node.js project's dependencies.  npm init -y  Install the undici library. This library includes a fetch function that you can use to make HTTP requests.  npm install undici  Finally, add npm install to your function's build commands in the Appwrite Console.    PHP  Run the following bash command to create a composer.json file. This file is used to manage your PHP project's dependencies.  composer init -y  Install the guzzlehttp/guzzle library. This library includes a get function that you can use to make HTTP requests.  composer require guzzlehttp/guzzle  Finally, add composer install to your function's build commands in the Appwrite Console.    Python  Run the following bash command to create a requirements.txt file. This file is used to manage your Python project's dependencies.  touch requirements.txt  Install the requests library. This library includes a get function that you can use to make HTTP requests.  echo \\\"requests\\\" >> requirements.txt\\npip install -r requirements.txt  Finally, add pip install -r requirements.txt to your function's build commands in the Appwrite Console.     Dart    Create a pubspec.yaml file with the following contents. This file is used to manage your Dart project's dependencies.   name: appwrite_function\\ndescription: Appwrite Function\\nversion: 1.0.0\\nenvironment:\\n  sdk: '>=2.12.0 <3.0.0'   Install the http library. This library includes a get function that you can use to make HTTP requests.   pub install http   Finally, add pub get to your function's build commands in the Appwrite Console.      Ruby    Create a Gemfile file with the following contents. This file is used to manage your Ruby project's dependencies.   source 'https://rubygems.org'   Install the httparty library. This library includes a get function that you can use to make HTTP requests.   echo \\\"gem 'httparty'\\\" >> Gemfile\\nbundle install   Finally, add bundle install to your function's build commands in the Appwrite Console.   \"]}, {\"level\": 3, \"title\": \"Code\", \"body\": [\"  Node.js    import { fetch } from 'undici';\\n\\nexport default async function ({ req, res }) {\\n  if (req.path === '/eur') {\\n    const amountInEuros = Number(req.query.amount);\\n    const response = await fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD');\\n    const data = await response.json();\\n    const amountInDollars = amountInEuros * data.rates.USD;\\n    return res.send(amountInDollars.toString());\\n  }\\n\\n  if (req.path === '/inr') {\\n    const amountInRupees = Number(req.query.amount);\\n    const response = await fetch('https://api.exchangerate.host/latest?base=INR&symbols=USD');\\n    const data = await response.json();\\n    const amountInDollars = amountInRupees * data.rates.USD;\\n    return res.send(amountInDollars.toString());\\n  }\\n\\n  return res.send('Invalid path');\\n};     Python    import requests\\n\\ndef main(context):\\n  if context.req.path == '/eur':\\n    amount_in_euros = float(context.req.query['amount'])\\n    response = requests.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')\\n    data = response.json()\\n    amount_in_dollars = amount_in_euros * data['rates']['USD']\\n    return context.res.send(str(amount_in_dollars))\\n\\n  if context.req.path == '/inr':\\n    amount_in_rupees = float(context.req.query['amount'])\\n    response = requests.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')\\n    data = response.json()\\n    amount_in_dollars = amount_in_rupees * data['rates']['USD']\\n    return context.res.send(str(amount_in_dollars))\\n\\n  return 'Invalid path'     Dart    import 'dart:async';\\nimport 'package:http/http.dart' as http;\\n\\nFuture<dynamic> main(final context) async {\\n  if (context.req.path == '/eur') {\\n    final amountInEuros = double.parse(context.req.query['amount'])\\n    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=EUR&symbols=USD'));\\n    final data = json.decode(response.body);\\n    final amountInDollars = amountInEuros * data['rates']['USD'];\\n    return context.res.send(amountInDollars.toString());\\n  }\\n\\n  if (context.req.path == '/inr') {\\n    final amountInRupees = double.parse(context.req.query['amount'])\\n    final response = await http.get(Uri.parse('https://api.exchangerate.host/latest?base=INR&symbols=USD'));\\n    final data = json.decode(response.body);\\n    final amountInDollars = amountInRupees * data['rates']['USD'];\\n    return context.res.send(amountInDollars.toString());\\n  }\\n\\n  return 'Invalid path';\\n}     Ruby    require 'httparty'\\n\\ndef main(context)\\n  if context.req.path == '/eur'\\n    amount_in_euros = context.req.query['amount'].to_f\\n    response = HTTParty.get('https://api.exchangerate.host/latest?base=EUR&symbols=USD')\\n    data = JSON.parse(response.body)\\n    amount_in_dollars = amount_in_euros * data['rates']['USD']\\n    return context.res.send(amount_in_dollars.to_s)\\n  end\\n\\n  if context.req.path == '/inr'\\n    amount_in_rupees = context.req.query['amount'].to_f\\n    response = HTTParty.get('https://api.exchangerate.host/latest?base=INR&symbols=USD')\\n    data = JSON.parse(response.body)\\n    amount_in_dollars = amount_in_rupees * data['rates']['USD']\\n    return context.res.send(amount_in_dollars.to_s)\\n  end\\n\\n  return 'Invalid path'\\nend   \", \" Use the function by navigating to function URL in the browser. The path should contain the currency and amount parameter. For example, [YOUR_FUNCTION_URL]/eur?amount=5 should convert Euros to Dollars.\"]}, {\"level\": 2, \"title\": \"Voting System Using Appwrite\", \"body\": [\" Here's a simple voting system that allows users to vote on various topics. Appwrite Functions and the server SDK are used to enforce voting rules and prevent multiple votes from the same user for a single topic.\"]}, {\"level\": 3, \"title\": \"Prerequisites\", \"body\": [\"Create a Topics collection with the following attributes:\", \"   Name Type Description     title string The name of the topic   description string Long form description of the topic  \", \"Create a Votes collection with the following attributes:\", \"   Name Type Description     userId string The ID of the user who cast the vote   topicId string The ID of the topic that was voted on   vote string The vote cast by the user. Must be either \\\"yes\\\" or \\\"no\\\"  \"]}, {\"level\": 3, \"title\": \"Code\", \"body\": [\"  Node.js   import { Client, Databases, Query } from 'node-appwrite';\\n\\nexport default async function ({ req, res }) {\\n  const vote = {\\n    userId: req.query.userId,\\n    topicId: req.query.topicId,\\n    vote: req.query.vote\\n  };\\n\\n  if (vote.vote !== 'yes' && vote.vote !== 'no') {\\n    return res.json({ ok: false, message: 'You must vote yes or no.' }, 400);\\n  }\\n\\n  const client = new Client();\\n  client\\n    .setEndpoint('https://cloud.appwrite.io/v1')\\n    .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)\\n    .setKey(process.env.APPWRITE_API_KEY);\\n\\n  const database = new Database(client);\\n  \\n  const existingVotes = await database.listDocuments('[VOTES_COLLECTION_ID]', [\\n    Query.equals('userId', vote.userId),\\n    Query.equals('topicId', vote.topicId)\\n  ]);\\n\\n  if (existingVotes.total > 0) {\\n    return res.json({ ok: false, message: 'You have already voted on this topic.' }, 400);\\n  }\\n\\n  const voteDocument = await database.createDocument('[VOTES_COLLECTION_ID]', {\\n    userId,\\n    topicId,\\n    vote,\\n  });\\n\\n  return res.json({ ok: true, message: 'Vote cast.', vote: voteDocument });\\n}     Python    from appwrite.client import Client\\nfrom appwrite.services.databases import Databases\\nfrom appwrite.query import Query\\nimport os\\n\\ndef main(context):\\n    vote = {\\n        'userId': context.req.query['userId'],\\n        'topicId': context.req.query['topicId'],\\n        'vote': context.req.query['vote']\\n    }\\n\\n    if vote['vote'] != 'yes' and vote['vote'] != 'no':\\n        return context.res.json({'ok': False, 'message': 'You must vote yes or no.'}, 400)\\n\\n    client = Client()\\n    client.set_endpoint('https://cloud.appwrite.io/v1')\\n    client.set_project(os.environ['APPWRITE_FUNCTION_PROJECT_ID'])\\n    client.set_key(os.environ['APPWRITE_API_KEY'])\\n\\n    database = Databases(client)\\n    \\n    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [\\n        Query.equals('userId', vote['userId']),\\n        Query.equals('topicId', vote['topicId'])\\n    ])\\n\\n    if existing_votes['total'] > 0:\\n        return context.res.json({\\n          'ok': False, \\n          'message': 'You have already voted on this topic.'\\n        }, 400)\\n\\n    vote_document = database.create_document('[VOTES_COLLECTION_ID]', {\\n        'userId': vote['userId'],\\n        'topicId': vote['topicId'],\\n        'vote': vote['vote'],\\n    })\\n\\n    return context.res.json({'ok': True, 'message': 'Vote cast.', 'vote': vote_document})     PHP    <?php\\n\\nrequire(__DIR__ . '/../vendor/autoload.php');\\n\\nuse Appwrite\\\\Client;\\nuse Appwrite\\\\Exception;\\nuse Appwrite\\\\Services\\\\Database;\\nuse Appwrite\\\\Query;\\n\\nreturn function ($context) {\\n    $vote = [\\n        'userId' => $context->req->query['userId'],\\n        'topicId' => $context->req->query['topicId'],\\n        'vote' => $context->req->query['vote']\\n    ];\\n\\n    if ($vote['vote'] !== 'yes' && $vote['vote'] !== 'no') {\\n        return $context->res->json(['ok' => false, 'message' => 'You must vote yes or no.'], 400);\\n    }\\n\\n    $client = new Client();\\n    $client\\n        ->setEndpoint('https://cloud.appwrite.io/v1')\\n        ->setProject(getenv('APPWRITE_FUNCTION_PROJECT_ID'))\\n        ->setKey(getenv('APPWRITE_API_KEY'));\\n\\n    $database = new Database($client);\\n\\n    $existingVotes = $database->listDocuments('[VOTES_COLLECTION_ID]', [\\n        Query->equal('userId', $vote['userId']),\\n        Query->equal('topicId', $vote['topicId'])\\n    ]);\\n\\n    if ($existingVotes['total'] > 0) {\\n        return $context->res->json([\\n          'ok' => false, \\n          'message' => 'You have already voted on this topic.'\\n        ], 400);\\n    }\\n\\n    $voteDocument = $database->createDocument('[VOTES_COLLECTION_ID]', [\\n        'userId' => $vote['userId'],\\n        'topicId' => $vote['topicId'],\\n        'vote' => $vote['vote'],\\n    ]);\\n\\n    return $context->res->json([\\n      'ok' => true, \\n      'message' => 'Vote cast.', \\n      'vote' => $voteDocument\\n    ]);\\n};     Ruby    require \\\"appwrite\\\"\\n\\ndef main(context)\\n    vote = {\\n        'userId' => context.req.query['userId'],\\n        'topicId' => context.req.query['topicId'],\\n        'vote' => context.req.query['vote']\\n    }\\n\\n    if vote['vote'] != 'yes' and vote['vote'] != 'no'\\n        return context.res.json({'ok': false, 'message': 'You must vote yes or no.'}, 400)\\n    end\\n\\n    client = Appwrite::Client.new()\\n    client\\n        .set_endpoint('https://cloud.appwrite.io/v1')\\n        .set_project(ENV['APPWRITE_FUNCTION_PROJECT_ID'])\\n        .set_key(ENV['APPWRITE_API_KEY'])\\n\\n    database = Appwrite::Database.new(client)\\n    \\n    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [\\n        Appwrite::Query.new('userId', '=', vote['userId']),\\n        Appwrite::Query.new('topicId', '=', vote['topicId'])\\n    ])\\n\\n    if existing_votes['total'] > 0\\n        return context.res.json({\\n          'ok': false, \\n          'message': 'You have already voted on this topic.'\\n        }, 400)\\n    end\\n\\n    vote_document = database.create_document('[VOTES_COLLECTION_ID]', {\\n        'userId': vote['userId'],\\n        'topicId': vote['topicId'],\\n        'vote': vote['vote'],\\n    })\\n\\n    return context.res.json({\\n      'ok': true, \\n      'message': 'Vote cast.', \\n      'vote': vote_document\\n    })\\nend     Dart    import 'dart:async';\\nimport 'package:dart_appwrite/dart_appwrite.dart';\\n\\nFuture main(final context) async {\\n    final vote = {\\n        'userId': context.req.query['userId'],\\n        'topicId': context.req.query['topicId'],\\n        'vote': context.req.query['vote']\\n    };\\n\\n    if (vote['vote'] != 'yes' && vote['vote'] != 'no') {\\n        return context.res.json({'ok': false, 'message': 'You must vote yes or no.'}, 400);\\n    }\\n\\n    final client = Client()\\n        .setEndpoint('https://cloud.appwrite.io/v1')\\n        .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)\\n        .setKey(process.env.APPWRITE_API_KEY);\\n\\n    final database = Database(client);\\n\\n    final existingVotes = await database.listDocuments('[VOTES_COLLECTION_ID]', [\\n        Query.equals('userId', vote['userId']),\\n        Query.equals('topicId', vote['topicId'])\\n    ]);\\n\\n    if (existingVotes['total'] > 0) {\\n        return context.res.json({\\n          'ok': false, \\n          'message': 'You have already voted on this topic.'\\n        }, 400);\\n    }\\n\\n    final voteDocument = await database.createDocument('[VOTES_COLLECTION_ID]', {\\n        'userId': vote['userId'],\\n        'topicId': vote['topicId'],\\n        'vote': vote['vote'],\\n    });\\n\\n    return context.res.json({\\n      'ok': true, \\n      'message': 'Vote cast.', \\n      'vote': voteDocument\\n    });\\n}     Python    from appwrite.client import Client\\nfrom appwrite.services.databases import Databases\\nfrom appwrite.query import Query\\n\\nimport os\\n\\ndef main(context):\\n    vote = {\\n        'userId': context.req.query['userId'],\\n        'topicId': context.req.query['topicId'],\\n        'vote': context.req.query['vote']\\n    }\\n\\n    if vote['vote'] != 'yes' and vote['vote'] != 'no':\\n        return context.res.json({'ok': False, 'message': 'You must vote yes or no.'}, 400)\\n\\n    client = Client()\\n    client.set_endpoint('https://cloud.appwrite.io/v1')\\n    client.set_project(os.environ['APPWRITE_FUNCTION_PROJECT_ID'])\\n    client.set_key(os.environ['APPWRITE_API_KEY'])\\n\\n    database = Databases(client)\\n\\n    existing_votes = database.list_documents('[VOTES_COLLECTION_ID]', [\\n        Query.equal('userId', vote['userId']),\\n        Query.equal('topicId', vote['topicId'])\\n    ])\\n    \\n    if existing_votes['total'] > 0:\\n        return context.res.json({\\n          'ok': False, \\n          'message': 'You have already voted on this topic.'\\n        }, 400)\\n\\n    vote_document = database.create_document('[VOTES_COLLECTION_ID]', vote)\\n\\n    return context.res.json({\\n      'ok': True, \\n      'message': 'Vote cast.', \\n      'vote': vote_document\\n    })   \", \" Use the function by navigating to the function URL in the browser. The URL should contain the required parameters. For example, [YOUR_FUNCTION_URL]/?userId=[USER_ID]&topicId=[TOPIC_ID]&vote=yes to cast a vote.\"]}, {\"level\": 2, \"title\": \"HTML Contact Form\", \"body\": [\" Here's a simple form page that handles form submissions, and can be used to store a user's message in a collection. The form is submitted to the function using the POST method and the form data is sent as a URL-encoded string in the request body.\"]}, {\"level\": 3, \"title\": \"Prerequisites\", \"body\": [\"Create a Messages collection with the following attributes:\", \"   Name Type Description     name string The name of the message author  email string The email of the message author   content string The content of the message  \"]}]", "metadata": {"source": "http://167.172.175.165:2080/docs/functions-examples"}}